{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The main goal of this tutorial is to learn the docker basic concepts from a user perspective and to get familiar with the docker cli.</p> <p>You will learn about:</p> <ul> <li>how docker stores images and manages container data</li> <li>how to run your first container</li> <li>how to run a service in a docker container and make it available outside of Docker</li> <li>how to persist your data</li> <li>how to install and use a docker web interface </li> </ul> <p>Note</p> <p>How to create (e.g. from a Dockerfile) or modify a docker image and share it using a registry is out of the scope of this tutorial and will be covered in part 2.</p>"},{"location":"container/env_vars/","title":"How to pass env variables to a container","text":"<p>An environment variable consists of a variable name and its value.</p> <p>There are two ways to set environment variables for a docker container: with CLI arguments, using an env file.</p>"},{"location":"container/env_vars/#cli-arguments","title":"CLI arguments","text":"<p>When we launch our Docker container, we can pass environment variables as key-value pairs directly into the command line using the parameter \u2013env (or its short form -e).</p> <p>For instance, let's execute the following command:</p> <pre><code>$ docker run --rm --env VARIABLE1=foobar alpine env\n</code></pre> <p>The environment variables we set will be printed to the console:</p> <pre><code>VARIABLE1=foobar\n</code></pre> <p>As can be seen, the Docker container correctly interprets the variable <code>VARIABLE1</code>.</p> <p>Also, we can omit the value in the command line if the variable already exists in the local environment.</p> <p>For example, let's define a local environment variable:</p> <pre><code>export VARIABLE2=foobar2\n</code></pre> <p>Then, let's specify the environment variable without its value:</p> <pre><code>docker run --rm --env VARIABLE2 alpine env\n</code></pre> <p>And we can see Docker still picked up the value, this time from the surrounding environment:</p> <pre><code>VARIABLE2=foobar2\n</code></pre>"},{"location":"container/env_vars/#using-env-file","title":"Using --env-file","text":"<p>The above solution is adequate when the number of variables is low. However, as soon as we have more than a handful of variables, it can quickly become cumbersome and error-prone.</p> <p>An alternative solution is to use a text file to store our variables, using the standard key=value format.</p> <p>Let's define a few variables in a file we'll call my-env.txt:</p> <pre><code>$ echo VARIABLE1=foobar1 &gt; my-env.txt\n$ echo VARIABLE2=foobar2 &gt;&gt; my-env.txt\n$ echo VARIABLE3=foobar3 &gt;&gt; my-env.txt\n</code></pre> <p>Now, let's inject this file into our Docker container:</p> <pre><code>$ docker run --env-file my-env.txt alpine:3 env\n</code></pre> <p>Finally, let's take a look at the output:</p> <pre><code>VARIABLE1=foobar1\nVARIABLE2=foobar2\nVARIABLE3=foobar3\n</code></pre>"},{"location":"container/example/","title":"Run a dockerized service","text":""},{"location":"container/example/#run-a-basic-http-server-in-a-docker-container","title":"Run a basic http server in a docker container","text":"<p>Let's deploy a simple web server using <code>nginx</code>. First of all, let's search on Docker Hub for an already available image.</p> <p>We can use the <code>search</code> command as follows:</p> <pre><code>docker search nginx\n</code></pre> <p>You will get something like the following output:</p> <pre><code>NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\nnginx                              Official build of Nginx.                        14963     [OK]\njwilder/nginx-proxy                Automated Nginx reverse proxy for docker con\u2026   2033                 [OK]\nricharvey/nginx-php-fpm            Container running Nginx + PHP-FPM capable of\u2026   813                  [OK]\njc21/nginx-proxy-manager           Docker container for managing Nginx proxy ho\u2026   197\nlinuxserver/nginx                  An Nginx container, brought to you by LinuxS\u2026   148\ntiangolo/nginx-rtmp                Docker image with Nginx using the nginx-rtmp\u2026   127                  [OK]\njlesage/nginx-proxy-manager        Docker container for Nginx Proxy Manager        115                  [OK]\nalfg/nginx-rtmp                    NGINX, nginx-rtmp-module and FFmpeg from sou\u2026   99                   [OK]\nbitnami/nginx                      Bitnami nginx Docker Image                      96                   [OK]\nnginxdemos/hello                   NGINX webserver that serves a simple page co\u2026   70                   [OK]\nprivatebin/nginx-fpm-alpine        PrivateBin running on an Nginx, php-fpm &amp; Al\u2026   53                   [OK]\nnginx/nginx-ingress                NGINX and  NGINX Plus Ingress Controllers fo\u2026   52\nnginxinc/nginx-unprivileged        Unprivileged NGINX Dockerfiles                  36\nstaticfloat/nginx-certbot          Opinionated setup for automatic TLS certs lo\u2026   23                   [OK]\nschmunk42/nginx-redirect           A very simple container to redirect HTTP tra\u2026   19                   [OK]\nnginx/nginx-prometheus-exporter    NGINX Prometheus Exporter for NGINX and NGIN\u2026   18\ncentos/nginx-112-centos7           Platform for running nginx 1.12 or building \u2026   15\ncentos/nginx-18-centos7            Platform for running nginx 1.8 or building n\u2026   13\nbitwarden/nginx                    The Bitwarden nginx web server acting as a r\u2026   11\nflashspys/nginx-static             Super Lightweight Nginx Image                   10                   [OK]\nmailu/nginx                        Mailu nginx frontend                            8                    [OK]\nbitnami/nginx-ingress-controller   Bitnami Docker Image for NGINX Ingress Contr\u2026   8                    [OK]\nnavidonskis/nginx-php5.6           Docker nginx + php5.6 on Ubuntu                 7                    [OK]\nansibleplaybookbundle/nginx-apb    An APB to deploy NGINX                          2                    [OK]\nwodby/nginx                        Generic nginx                                   1                    [OK]\n</code></pre> <p>Tip</p> <p>The <code>docker search</code> command returns the following image information:</p> <ul> <li>Repository names</li> <li>Image descriptions</li> <li>Stars - these measure the popularity of an image</li> <li>Official - an image managed by the upstream developer (e.g., the fedora image managed by the Fedora team) </li> <li>Automated - an image built by the Docker Hub's Automated Build process</li> </ul> <p>In alternative, you can make a similar search on the Docker Hub Web site:</p> <p></p> <p>Let's download the official image using the <code>docker image pull</code> command:</p> <pre><code>docker image pull nginx\n</code></pre> <pre><code>Using default tag: latest\nlatest: Pulling from library/nginx\n69692152171a: Pull complete\n30afc0b18f67: Pull complete\n596b1d696923: Pull complete\nfebe5bd23e98: Pull complete\n8283eee92e2f: Pull complete\n351ad75a6cfa: Pull complete\nDigest: sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750\nStatus: Downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\n</code></pre> <p>In order to list the images downloaded on your host, you can use the command:</p> <p><pre><code>docker image ls \n</code></pre> The output of this command provides useful information, including the size of the image:</p> <pre><code>REPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nnginx        latest    d1a364dc548d   10 days ago   133MB\nubuntu       latest    7e0aa2d69a15   5 weeks ago   72.7MB\n</code></pre> <p>Let's have a look at the image with the commands we have already seen in the previous section:</p> <pre><code>docker image inspect nginx\n</code></pre> <pre><code>[\n    {\n        \"Id\": \"sha256:d1a364dc548d5357f0da3268c888e1971bbdb957ee3f028fe7194f1d61c6fdee\",\n        \"RepoTags\": [\n            \"nginx:latest\"\n        ],\n        \"RepoDigests\": [\n            \"nginx@sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750\"\n        ],\n        \"Parent\": \"\",\n        \"Comment\": \"\",\n        \"Created\": \"2021-05-25T15:43:43.382480482Z\",\n        \"Container\": \"7b06b818c018bb8563a3d786d6b16971c6f470c3d4c5288d908a3851b8261086\",\n        \"ContainerConfig\": {\n            \"Hostname\": \"7b06b818c018\",\n            \"Domainname\": \"\",\n            \"User\": \"\",\n            \"AttachStdin\": false,\n            \"AttachStdout\": false,\n            \"AttachStderr\": false,\n            \"ExposedPorts\": {\n                \"80/tcp\": {}\n            },\n            \"Tty\": false,\n            \"OpenStdin\": false,\n            \"StdinOnce\": false,\n            \"Env\": [\n                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n                \"NGINX_VERSION=1.21.0\",\n                \"NJS_VERSION=0.5.3\",\n                \"PKG_RELEASE=1~buster\"\n            ],\n            \"Cmd\": [\n                \"/bin/sh\",\n                \"-c\",\n                \"#(nop) \",\n                \"CMD [\\\"nginx\\\" \\\"-g\\\" \\\"daemon off;\\\"]\"\n            ],\n            \"Image\": \"sha256:697718de459ceac2204a10028cb4008e64513e26697c154309ae93d2f64baa57\",\n            \"Volumes\": null,\n            \"WorkingDir\": \"\",\n            \"Entrypoint\": [\n                \"/docker-entrypoint.sh\"\n            ],\n            \"OnBuild\": null,\n            \"Labels\": {\n                \"maintainer\": \"NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;\"\n            },\n            \"StopSignal\": \"SIGQUIT\"\n        },\n        \"DockerVersion\": \"19.03.12\",\n        \"Author\": \"\",\n        \"Config\": {\n            \"Hostname\": \"\",\n            \"Domainname\": \"\",\n            \"User\": \"\",\n            \"AttachStdin\": false,\n            \"AttachStdout\": false,\n            \"AttachStderr\": false,\n            \"ExposedPorts\": {\n                \"80/tcp\": {}\n            },\n            \"Tty\": false,\n            \"OpenStdin\": false,\n            \"StdinOnce\": false,\n            \"Env\": [\n                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n                \"NGINX_VERSION=1.21.0\",\n                \"NJS_VERSION=0.5.3\",\n                \"PKG_RELEASE=1~buster\"\n            ],\n            \"Cmd\": [\n                \"nginx\",\n                \"-g\",\n                \"daemon off;\"\n            ],\n            \"Image\": \"sha256:697718de459ceac2204a10028cb4008e64513e26697c154309ae93d2f64baa57\",\n            \"Volumes\": null,\n            \"WorkingDir\": \"\",\n            \"Entrypoint\": [\n                \"/docker-entrypoint.sh\"\n            ],\n            \"OnBuild\": null,\n            \"Labels\": {\n                \"maintainer\": \"NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;\"\n            },\n            \"StopSignal\": \"SIGQUIT\"\n        },\n        \"Architecture\": \"amd64\",\n        \"Os\": \"linux\",\n        \"Size\": 133117876,\n        \"VirtualSize\": 133117876,\n        \"GraphDriver\": {\n            \"Data\": {\n                \"LowerDir\": \"/var/lib/docker/overlay2/fa16037866db03e19d99c1d3695d6951569e751ba938036bcc1e82e31dad41cb/diff:/var/lib/docker/overlay2/adf9f3208ebac0a1566f031e9404f218349446153d3124c46c96d0db7d1b6097/diff:/var/lib/docker/overlay2/a5121e4e639c611e78ca69f1f5d90d032249852a6927b12968ac7709945f41e4/diff:/var/lib/docker/overlay2/8bf60f425fa90fe22dd757fc45d388c568254b79ec6f5bf724ac6a3a7972af84/diff:/var/lib/docker/overlay2/d75a9d8d1cabc06f29c2d1ea6854083e8de20bec99df58efed06bcbc01a9e0f4/diff\",\n                \"MergedDir\": \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/merged\",\n                \"UpperDir\": \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/diff\",\n                \"WorkDir\": \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/work\"\n            },\n            \"Name\": \"overlay2\"\n        },\n        \"RootFS\": {\n            \"Type\": \"layers\",\n            \"Layers\": [\n                \"sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33\",\n                \"sha256:766fe2c3fc083fdb0e132c138118bc931e3cd1bf4a8bdf0e049afbf64bae5ee6\",\n                \"sha256:83634f76e73296b28a0e90c640494970bdfc437749598e0e91e77eea9bdb6a4e\",\n                \"sha256:134e19b2fac580eff84faabfd5067977b79e36c5981d51fd63e8ac752dbdf9ec\",\n                \"sha256:5c865c78bc96874203b5aa48f1a089d1eabcbe1607edaa16aaa6dee27c985395\",\n                \"sha256:075508cf8f04705d8dc648cfb9f044f5dff57c31ccf34bde32cd2874f402dfad\"\n            ]\n        },\n        \"Metadata\": {\n            \"LastTagTime\": \"0001-01-01T00:00:00Z\"\n        }\n    }\n]\n</code></pre> <p>We can see that the nginx version in our container will be <code>1.21.0</code>, the service will be listening on port <code>80</code> and the command that will be executed at the container start is <code>nginx -g daemon off;</code>.</p> <p>This is a useful exercise, but in general you will find these information in the description of the image on Docker hub.</p>"},{"location":"container/example/#creating-a-daemonized-container","title":"Creating a daemonized container","text":"<p>In addition to the interactive containers, we can create longer-running containers. </p> <p>Daemonized containers don't have the interactive session we've used in our previous example and are ideal for running applications and services.  Most of the containers you're likely to run will probably be daemonized. </p> <p>Let's start a daemonized container now.</p> <pre><code>docker container run -d --name nginx nginx\n</code></pre> <p>Note</p> <p>The <code>-d</code> flag tells Docker to detach the container to the background. The <code>--name</code> option allows to set a name for your container</p> <p>Instead of being attached to a shell, the <code>docker run</code> command has instead returned a container ID and returned us to our command prompt. </p> <p>We can see our container running with:</p> <pre><code>docker container ps\n</code></pre> <pre><code>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES\n2f03f1f2cd10   nginx     \"/docker-entrypoint.\u2026\"   13 seconds ago   Up 11 seconds   80/tcp    nginx\n</code></pre>"},{"location":"container/example/#getting-the-container-log","title":"Getting the container log","text":"<p>What's happening inside our container? We can use the <code>docker container logs</code> command to fetch the log of a container:</p> <pre><code>docker container logs nginx\n</code></pre> <pre><code>/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration\n/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh\n10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf\n10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh\n/docker-entrypoint.sh: Configuration complete; ready for start up\n2021/06/06 14:52:38 [notice] 1#1: using the \"epoll\" event method\n2021/06/06 14:52:38 [notice] 1#1: nginx/1.21.0\n2021/06/06 14:52:38 [notice] 1#1: built by gcc 8.3.0 (Debian 8.3.0-6)\n2021/06/06 14:52:38 [notice] 1#1: OS: Linux 5.4.0-60-generic\n2021/06/06 14:52:38 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576\n2021/06/06 14:52:38 [notice] 1#1: start worker processes\n2021/06/06 14:52:38 [notice] 1#1: start worker process 32\n2021/06/06 14:52:38 [notice] 1#1: start worker process 33\n</code></pre> <p>Tip</p> <p>We can also monitor the container's logs much like the <code>tail -f</code> binary operates using the <code>-f</code> flag. You can also tail a portion of the logs of a container by using the <code>--tail</code> option. Moreover you can also use the <code>-t</code> flag to prefix the log entries with timestamps.</p>"},{"location":"container/example/#inspecting-the-container-processes","title":"Inspecting the container processes","text":"<p>We can inspect the processes running inside our container using the <code>docker container top</code> command:</p> <pre><code>UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD\nroot                138792              138771              0                   14:52               ?                   00:00:00            nginx: master process nginx -g daemon off;\nsystemd+            138861              138792              0                   14:52               ?                   00:00:00            nginx: worker process\nsystemd+            138862              138792              0                   14:52               ?                   00:00:00            nginx: worker process\n</code></pre>"},{"location":"container/example/#finding-out-more-about-our-container","title":"Finding out more about our container","text":"<p>Let's use again the command <code>docker container inspect</code> to get more information about our container:</p> command <pre><code>docker container inspect nginx\n</code></pre> Output <pre><code>[\n    {\n        \"Id\": \"2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a\",\n        \"Created\": \"2021-06-06T14:52:36.827435939Z\",\n        \"Path\": \"/docker-entrypoint.sh\",\n        \"Args\": [\n            \"nginx\",\n            \"-g\",\n            \"daemon off;\"\n        ],\n        \"State\": {\n            \"Status\": \"running\",\n            \"Running\": true,\n            \"Paused\": false,\n            \"Restarting\": false,\n            \"OOMKilled\": false,\n            \"Dead\": false,\n            \"Pid\": 138792,\n            \"ExitCode\": 0,\n            \"Error\": \"\",\n            \"StartedAt\": \"2021-06-06T14:52:38.171320981Z\",\n            \"FinishedAt\": \"0001-01-01T00:00:00Z\"\n        },\n        \"Image\": \"sha256:d1a364dc548d5357f0da3268c888e1971bbdb957ee3f028fe7194f1d61c6fdee\",\n        \"ResolvConfPath\": \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/resolv.conf\",\n        \"HostnamePath\": \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/hostname\",\n        \"HostsPath\": \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/hosts\",\n        \"LogPath\": \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a-json.log\",\n        \"Name\": \"/nginx\",\n        \"RestartCount\": 0,\n        \"Driver\": \"overlay2\",\n        \"Platform\": \"linux\",\n        \"MountLabel\": \"\",\n        \"ProcessLabel\": \"\",\n        \"AppArmorProfile\": \"docker-default\",\n        \"ExecIDs\": null,\n        \"HostConfig\": {\n            \"Binds\": null,\n            \"ContainerIDFile\": \"\",\n            \"LogConfig\": {\n                \"Type\": \"json-file\",\n                \"Config\": {\n                    \"max-file\": \"3\",\n                    \"max-size\": \"100m\"\n                }\n            },\n            \"NetworkMode\": \"default\",\n            \"PortBindings\": {},\n            \"RestartPolicy\": {\n                \"Name\": \"no\",\n                \"MaximumRetryCount\": 0\n            },\n            \"AutoRemove\": false,\n            \"VolumeDriver\": \"\",\n            \"VolumesFrom\": null,\n            \"CapAdd\": null,\n            \"CapDrop\": null,\n            \"CgroupnsMode\": \"host\",\n            \"Dns\": [],\n            \"DnsOptions\": [],\n            \"DnsSearch\": [],\n            \"ExtraHosts\": null,\n            \"GroupAdd\": null,\n            \"IpcMode\": \"private\",\n            \"Cgroup\": \"\",\n            \"Links\": null,\n            \"OomScoreAdj\": 0,\n            \"PidMode\": \"\",\n            \"Privileged\": false,\n            \"PublishAllPorts\": false,\n            \"ReadonlyRootfs\": false,\n            \"SecurityOpt\": null,\n            \"UTSMode\": \"\",\n            \"UsernsMode\": \"\",\n            \"ShmSize\": 67108864,\n            \"Runtime\": \"runc\",\n            \"ConsoleSize\": [\n                0,\n                0\n            ],\n            \"Isolation\": \"\",\n            \"CpuShares\": 0,\n            \"Memory\": 0,\n            \"NanoCpus\": 0,\n            \"CgroupParent\": \"\",\n            \"BlkioWeight\": 0,\n            \"BlkioWeightDevice\": [],\n            \"BlkioDeviceReadBps\": null,\n            \"BlkioDeviceWriteBps\": null,\n            \"BlkioDeviceReadIOps\": null,\n            \"BlkioDeviceWriteIOps\": null,\n            \"CpuPeriod\": 0,\n            \"CpuQuota\": 0,\n            \"CpuRealtimePeriod\": 0,\n            \"CpuRealtimeRuntime\": 0,\n            \"CpusetCpus\": \"\",\n            \"CpusetMems\": \"\",\n            \"Devices\": [],\n            \"DeviceCgroupRules\": null,\n            \"DeviceRequests\": null,\n            \"KernelMemory\": 0,\n            \"KernelMemoryTCP\": 0,\n            \"MemoryReservation\": 0,\n            \"MemorySwap\": 0,\n            \"MemorySwappiness\": null,\n            \"OomKillDisable\": false,\n            \"PidsLimit\": null,\n            \"Ulimits\": null,\n            \"CpuCount\": 0,\n            \"CpuPercent\": 0,\n            \"IOMaximumIOps\": 0,\n            \"IOMaximumBandwidth\": 0,\n            \"MaskedPaths\": [\n                \"/proc/asound\",\n                \"/proc/acpi\",\n                \"/proc/kcore\",\n                \"/proc/keys\",\n                \"/proc/latency_stats\",\n                \"/proc/timer_list\",\n                \"/proc/timer_stats\",\n                \"/proc/sched_debug\",\n                \"/proc/scsi\",\n                \"/sys/firmware\"\n            ],\n            \"ReadonlyPaths\": [\n                \"/proc/bus\",\n                \"/proc/fs\",\n                \"/proc/irq\",\n                \"/proc/sys\",\n                \"/proc/sysrq-trigger\"\n            ]\n        },\n        \"GraphDriver\": {\n            \"Data\": {\n                \"LowerDir\": \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d-init/diff:/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/diff:/var/lib/docker/overlay2/fa16037866db03e19d99c1d3695d6951569e751ba938036bcc1e82e31dad41cb/diff:/var/lib/docker/overlay2/adf9f3208ebac0a1566f031e9404f218349446153d3124c46c96d0db7d1b6097/diff:/var/lib/docker/overlay2/a5121e4e639c611e78ca69f1f5d90d032249852a6927b12968ac7709945f41e4/diff:/var/lib/docker/overlay2/8bf60f425fa90fe22dd757fc45d388c568254b79ec6f5bf724ac6a3a7972af84/diff:/var/lib/docker/overlay2/d75a9d8d1cabc06f29c2d1ea6854083e8de20bec99df58efed06bcbc01a9e0f4/diff\",\n                \"MergedDir\": \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/merged\",\n                \"UpperDir\": \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/diff\",\n                \"WorkDir\": \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/work\"\n            },\n            \"Name\": \"overlay2\"\n        },\n        \"Mounts\": [],\n        \"Config\": {\n            \"Hostname\": \"2f03f1f2cd10\",\n            \"Domainname\": \"\",\n            \"User\": \"\",\n            \"AttachStdin\": false,\n            \"AttachStdout\": false,\n            \"AttachStderr\": false,\n            \"ExposedPorts\": {\n                \"80/tcp\": {}\n            },\n            \"Tty\": false,\n            \"OpenStdin\": false,\n            \"StdinOnce\": false,\n            \"Env\": [\n                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n                \"NGINX_VERSION=1.21.0\",\n                \"NJS_VERSION=0.5.3\",\n                \"PKG_RELEASE=1~buster\"\n            ],\n            \"Cmd\": [\n                \"nginx\",\n                \"-g\",\n                \"daemon off;\"\n            ],\n            \"Image\": \"nginx\",\n            \"Volumes\": null,\n            \"WorkingDir\": \"\",\n            \"Entrypoint\": [\n                \"/docker-entrypoint.sh\"\n            ],\n            \"OnBuild\": null,\n            \"Labels\": {\n                \"maintainer\": \"NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;\"\n            },\n            \"StopSignal\": \"SIGQUIT\"\n        },\n        \"NetworkSettings\": {\n            \"Bridge\": \"\",\n            \"SandboxID\": \"a74ea121ebf1163153ed7f24fb22b4cc11af77f336cfdbee9252d7c80ed9be0f\",\n            \"HairpinMode\": false,\n            \"LinkLocalIPv6Address\": \"\",\n            \"LinkLocalIPv6PrefixLen\": 0,\n            \"Ports\": {\n                \"80/tcp\": null\n            },\n            \"SandboxKey\": \"/var/run/docker/netns/a74ea121ebf1\",\n            \"SecondaryIPAddresses\": null,\n            \"SecondaryIPv6Addresses\": null,\n            \"EndpointID\": \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\",\n            \"Gateway\": \"172.17.0.1\",\n            \"GlobalIPv6Address\": \"\",\n            \"GlobalIPv6PrefixLen\": 0,\n            \"IPAddress\": \"172.17.0.2\",\n            \"IPPrefixLen\": 16,\n            \"IPv6Gateway\": \"\",\n            \"MacAddress\": \"02:42:ac:11:00:02\",\n            \"Networks\": {\n                \"bridge\": {\n                    \"IPAMConfig\": null,\n                    \"Links\": null,\n                    \"Aliases\": null,\n                    \"NetworkID\": \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\",\n                    \"EndpointID\": \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\",\n                    \"Gateway\": \"172.17.0.1\",\n                    \"IPAddress\": \"172.17.0.2\",\n                    \"IPPrefixLen\": 16,\n                    \"IPv6Gateway\": \"\",\n                    \"GlobalIPv6Address\": \"\",\n                    \"GlobalIPv6PrefixLen\": 0,\n                    \"MacAddress\": \"02:42:ac:11:00:02\",\n                    \"DriverOpts\": null\n                }\n            }\n        }\n    }\n] \n</code></pre> <p>We can also selectively query the inspect results hash using the <code>-f</code> or <code>--format</code> flag.</p> <p>For example, let's retrieve the container network address:</p> <pre><code>docker container inspect -f '{{.NetworkSettings.IPAddress}}' nginx\n</code></pre> <pre><code>172.17.0.2\n</code></pre>"},{"location":"container/manipulation/","title":"Work with your first container","text":"<p>If you read the output from our <code>hello world</code>, they even recommend what to try next.</p> <p><pre><code>docker container run -it ubuntu bash\n</code></pre> Let's see what happens:</p> <pre><code>Unable to find image 'ubuntu:latest' locally\nlatest: Pulling from library/ubuntu\n345e3491a907: Pull complete\n57671312ef6f: Pull complete\n5e9250ddb7d0: Pull complete\nDigest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d\nStatus: Downloaded newer image for ubuntu:latest\n</code></pre> <p>We are inside the docker container!</p> <p>Tip</p> <p>You need to use the <code>-it</code> option whenever you want to run a container in interactive mode. - The <code>-i</code> or <code>--interactive</code> option connects you to the input stream of the container, so that you can send inputs to bash; - The <code>-t</code> or <code>--tty</code> option makes sure that you get some good formatting and a native terminal-like experience by allocating a pseudo-tty. </p>"},{"location":"container/manipulation/#playing-with-a-running-container","title":"Playing with a running container","text":"<p>This is a fully fledged Ubuntu host, and we can do anything we like in it. Let's explore it a bit, starting with asking for its hostname:</p> <pre><code>root@a5a2c01df566:/# hostname\na5a2c01df566\n</code></pre> <p>We can see that our container's hostname is the container ID. Let's have a look at the <code>/etc/hosts</code> file too. <pre><code>root@a5a2c01df566:/# cat /etc/hosts\n127.0.0.1   localhost\n::1 localhost ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n172.17.0.2  a5a2c01df566\n</code></pre> Docker has also added a host entry for our container with its IP address. Let's also check out its networking configuration.</p> <pre><code>root@a5a2c01df566:/# ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n85: eth0@if86: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default\n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n</code></pre> <p>ip: command not found</p> <p>Install the package <code>iproute2</code> that provides a collection of utilities for networking and traffic control. <pre><code>   apt update &amp;&amp; apt install -y iproute2\n</code></pre></p> <p>As we can see, we have the <code>lo</code> loopback interface and the <code>eth0@if86</code> network interface with an IP address of 172.17.0.2, just like any other host. </p> <p>We can also check its running processes:</p> <pre><code>root@a5a2c01df566:/# ps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.0  0.0   4216  3588 pts/0    Ss   08:46   0:00 bash\nroot         601  0.0  0.0   5896  2852 pts/0    R+   10:17   0:00 ps aux\n</code></pre> <p>Note that the process <code>bash</code> has PID 1. </p> <p>Now type <code>exit</code> or the <code>CTRL-d</code> key sequence...you'll return to the command prompt of your Ubuntu host. So what's happened to our container?  The container only runs for as long as the command we specified, <code>/bin/bash</code>, is running. Once we exited the container, that command ended, and the container was stopped.</p> <p>So the container still exists but it's stopped: <pre><code>docker container ps -a\nCONTAINER ID   IMAGE     COMMAND   CREATED       STATUS                     PORTS     NAMES\na5a2c01df566   ubuntu    \"bash\"    2 hours ago   Exited (0) 6 seconds ago             festive_cerf\n</code></pre></p>"},{"location":"container/manipulation/#starting-a-stopped-container","title":"Starting a stopped container","text":"<p>We can start again our stopped container with <code>docker container start &lt;container-id or container-name&gt;</code>:</p> <p><pre><code>docker container start a5a2c01df566\na5a2c01df566\n</code></pre> Our container will restart with the same options we had specified when we launched it with the <code>docker run</code> command.</p>"},{"location":"container/manipulation/#attaching-to-a-container","title":"Attaching to a container","text":"<p>The <code>docker container attach</code> command allows you to attach your terminal to the running container. </p> <p>Tip</p> <p>The command that is executed when starting a container is specified using the ENTRYPOINT and/or CMD instruction in the Dockerfile. The <code>attach</code> command allows you to connect and interact with the container\u2019s main process which has <code>PID 1</code>. Remember that if you kill the main process the container will terminate.</p> <p>This is useful when you want to see what is written in the standard output in real-time, or to control the process interactively.</p> <p>So running the <code>attach</code> command on our Ubuntu container will bring us back to our bash prompt: <pre><code>docker container attach a5a2c01df566\nroot@a5a2c01df566:/#\n</code></pre></p> <p>You can detach from a container and leave it running using the <code>CTRL-p CTRL-q</code> key sequence.</p> <p>What happens if you type <code>exit</code>?</p>"},{"location":"container/manipulation/#getting-a-shell-to-a-container","title":"Getting a shell to a container","text":"<p>The <code>docker exec</code> command allows you to run commands inside a running container. The command can be run in background using the option <code>-d</code> or interactively using the option <code>-i</code>.</p> <p>Try the following command on your Ubuntu container:</p> <p><pre><code>docker exec -it a5a2c01df566 bash\nroot@a5a2c01df566:/#\n</code></pre> Let's look at the processes inside the container: <pre><code>root@a5a2c01df566:/# ps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.0  0.0   4108  3420 pts/0    Ss+  14:05   0:00 bash\nroot           9  0.6  0.0   4108  3468 pts/1    Ss   14:06   0:00 bash\nroot          17  0.0  0.0   5896  2848 pts/1    R+   14:06   0:00 ps aux\n</code></pre> We can see that the <code>exec</code> command started a new shell session. </p> <p>Tip</p> <p>Usually the <code>exec</code> command is used to launch <code>bash</code> within the container and work with that.  The <code>attach</code> command primarily is used if you quickly want to see the output of the main process (<code>PID 1</code>) directly and/or want to kill it.</p>"},{"location":"container/networking/","title":"Bridge mode and port mapping","text":"<p>Let's start from the nginx docker container started in the previous section.</p> <p>The <code>inspect</code> command provided details about the networking configuration of the container:</p> <pre><code>...\n            \"Networks\": {\n                \"bridge\": {\n                    \"IPAMConfig\": null,\n                    \"Links\": null,\n                    \"Aliases\": null,\n                    \"NetworkID\": \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\",\n                    \"EndpointID\": \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\",\n                    \"Gateway\": \"172.17.0.1\",\n                    \"IPAddress\": \"172.17.0.2\",\n                    \"IPPrefixLen\": 16,\n                    \"IPv6Gateway\": \"\",\n                    \"GlobalIPv6Address\": \"\",\n                    \"GlobalIPv6PrefixLen\": 0,\n                    \"MacAddress\": \"02:42:ac:11:00:02\",\n                    \"DriverOpts\": null\n                }\n            }\n...\n</code></pre> <p>To list out the networks in your system, execute the following command:</p> <pre><code>docker network ls \n</code></pre> <pre><code>NETWORK ID     NAME      DRIVER    SCOPE\n0aa786b7de5f   bridge    bridge    local\n19747c3d0c9a   host      host      local\n36dc4ef5b900   none      null      local\n</code></pre> <p>As you can see, our container is attached to the default brige network <code>0aa786b7de5f</code> (long ID: 0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514). We get more details about this network with the <code>inspect</code> command:</p> <pre><code>docker network inspect 0aa786b7de5f\n</code></pre> <pre><code>[\n    {\n        \"Name\": \"bridge\",\n        \"Id\": \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\",\n        \"Created\": \"2021-05-27T13:27:32.164161898Z\",\n        \"Scope\": \"local\",\n        \"Driver\": \"bridge\",\n        \"EnableIPv6\": false,\n        \"IPAM\": {\n            \"Driver\": \"default\",\n            \"Options\": null,\n            \"Config\": [\n                {\n                    \"Subnet\": \"172.17.0.0/16\",\n                    \"Gateway\": \"172.17.0.1\"\n                }\n            ]\n        },\n        \"Internal\": false,\n        \"Attachable\": false,\n        \"Ingress\": false,\n        \"ConfigFrom\": {\n            \"Network\": \"\"\n        },\n        \"ConfigOnly\": false,\n        \"Containers\": {\n            \"2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a\": {\n                \"Name\": \"nginx\",\n                \"EndpointID\": \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\",\n                \"MacAddress\": \"02:42:ac:11:00:02\",\n                \"IPv4Address\": \"172.17.0.2/16\",\n                \"IPv6Address\": \"\"\n            }\n        },\n        \"Options\": {\n            \"com.docker.network.bridge.default_bridge\": \"true\",\n            \"com.docker.network.bridge.enable_icc\": \"true\",\n            \"com.docker.network.bridge.enable_ip_masquerade\": \"true\",\n            \"com.docker.network.bridge.host_binding_ipv4\": \"0.0.0.0\",\n            \"com.docker.network.bridge.name\": \"docker0\",\n            \"com.docker.network.driver.mtu\": \"1500\"\n        },\n        \"Labels\": {}\n    }\n]\n</code></pre> <p>We can see that the container has an IP address of <code>172.17.0.2</code> and uses the gateway address of the <code>docker0</code> interface.</p> <p>Now we know that our nginx service is running on port 80 inside the container. </p> <p>Indeed we can contact our service on port <code>80</code> using the IP <code>172.17.0.2</code>, try the following command from your docker host:</p> <pre><code>curl http://172.17.0.2:80\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>All the containers attached to the default bridge network can talk each other.</p> <p>What if we want to reach the service running in the container using the local network on the host? </p> <p>Try the following command:</p> <p><pre><code>curl http://127.0.0.1:80\n</code></pre> It won't work..you will get: <code>curl: (7) Failed to connect to 127.0.0.1 port 80: Connection refused</code>...</p> <p>We need to publish the service port in the container to a port on our local network. This can be done using the <code>--publish</code> option (or <code>-p</code>) of the <code>docker container run</code> command. The correct syntax is:</p> <pre><code>--publish &lt;host port&gt;:&lt;container port&gt;\n</code></pre> <p>So let's start another container with this option:</p> <pre><code>docker container run -d --name nginx2 -p 80:80 nginx\n</code></pre> <p>Look at the different description of the two containers:</p> <pre><code>docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                               NAMES\n8d5609a40033   nginx     \"/docker-entrypoint.\u2026\"   35 seconds ago   Up 33 seconds   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx2\n2f03f1f2cd10   nginx     \"/docker-entrypoint.\u2026\"   2 hours ago      Up 2 hours      80/tcp                              nginx\n</code></pre> <p>We can see here that the container port 80 is mapped on the host port 80 (<code>0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp</code>).</p> <p>As before, the command <code>docker container inspect</code> provides further information:</p> <pre><code>...\n        \"NetworkSettings\": {\n            \"Bridge\": \"\",\n            \"SandboxID\": \"c66c74726ef8185887d6057d9efd1a4870f0b4b77543213d3bb4fe80db2bd48b\",\n            \"HairpinMode\": false,\n            \"LinkLocalIPv6Address\": \"\",\n            \"LinkLocalIPv6PrefixLen\": 0,\n            \"Ports\": {\n                \"80/tcp\": [\n                    {\n                        \"HostIp\": \"0.0.0.0\",\n                        \"HostPort\": \"80\"\n                    },\n                    {\n                        \"HostIp\": \"::\",\n                        \"HostPort\": \"80\"\n                    }\n                ]\n            },\n...\n</code></pre> <p>Now we can verify that our service is reachable on port 80 of our local network running the following command from the host:</p> <pre><code>curl http://127.0.0.1:80\n</code></pre> <p>Indeed you can reach your service also from outside using the IP of your host. If the inbound connectivity on port 80 is ensured by the firewall rules, you can connect to the nginx service using the browser on your local workstation.</p> <p> </p>"},{"location":"container/networking/#using-a-user-defined-bridge-network","title":"Using a user-defined bridge network","text":"<p>In the previous example we have seen that any container you run will be automatically attached to the default bridge network.</p> <p>Tip</p> <p>A user-defined bridge network has some important extra features w.r.t. the default one as described in the official docs on this topic:</p> <ul> <li>Automatic DNS resolution between containers</li> <li>Better isolation</li> <li>Containers can be attached and detached from user-defined networks on the fly</li> <li>Each user-defined network creates a configurable bridge</li> </ul> <p>Now use the <code>docker network create</code> command to create a user-defined bridge network:</p> <p><pre><code>docker network create mynet\n</code></pre> You will get the ID of the newly created network, e.g.:</p> <pre><code>64319187a52ba82fcbff86b348b42c3ac847e5cfb6a2365b123b7de597ff6eee\n</code></pre> <p>List the docker networks: you will see also <code>mynet</code> in the list:</p> <pre><code>docker network ls\nNETWORK ID     NAME      DRIVER    SCOPE\n0aa786b7de5f   bridge    bridge    local\n19747c3d0c9a   host      host      local\n64319187a52b   mynet     bridge    local\n36dc4ef5b900   none      null      local\n</code></pre> <p>We can use the <code>network connect</code> command to attach a container to a network.</p> <p>Tip</p> <p>The syntax for this command is: <code>docker network connect &lt;network identifier&gt; &lt;container identifier&gt;</code></p> <p>Let's connect our first <code>nginx</code> container:</p> <pre><code>docker network connect mynet nginx\n</code></pre> <p>Note that the container was already attached to the default bridge network. Let's inspect the container to get the new networking configuration:</p> <pre><code>docker inspect nginx\n</code></pre> <p><pre><code>...\n\"Networks\": {\n                \"bridge\": {\n                    \"IPAMConfig\": null,\n                    \"Links\": null,\n                    \"Aliases\": null,\n                    \"NetworkID\": \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\",\n                    \"EndpointID\": \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\",\n                    \"Gateway\": \"172.17.0.1\",\n                    \"IPAddress\": \"172.17.0.2\",\n                    \"IPPrefixLen\": 16,\n                    \"IPv6Gateway\": \"\",\n                    \"GlobalIPv6Address\": \"\",\n                    \"GlobalIPv6PrefixLen\": 0,\n                    \"MacAddress\": \"02:42:ac:11:00:02\",\n                    \"DriverOpts\": null\n                },\n                \"mynet\": {\n                    \"IPAMConfig\": {},\n                    \"Links\": null,\n                    \"Aliases\": [\n                        \"2f03f1f2cd10\"\n                    ],\n                    \"NetworkID\": \"64319187a52ba82fcbff86b348b42c3ac847e5cfb6a2365b123b7de597ff6eee\",\n                    \"EndpointID\": \"a232b9e5a82960e12762b949bc83b3e3bd5357580f937b69cae7097384e9eb69\",\n                    \"Gateway\": \"172.18.0.1\",\n                    \"IPAddress\": \"172.18.0.2\",\n                    \"IPPrefixLen\": 16,\n                    \"IPv6Gateway\": \"\",\n                    \"GlobalIPv6Address\": \"\",\n                    \"GlobalIPv6PrefixLen\": 0,\n                    \"MacAddress\": \"02:42:ac:12:00:02\",\n                    \"DriverOpts\": {}\n                }\n            }\n...\n</code></pre> As you can see, our container has now two interfaces with IPs 172.17.0.2 (on the default network) and 172.18.0.2 (on <code>mynet</code> network).</p> <p>Note that we can also specify the network when we create the container using the <code>--network</code> option. Let's run the following command:</p> <pre><code>docker run -it --net mynet ubuntu bash\n</code></pre> <p>In this way you have created a container that is connected to <code>mynet</code> network. </p> <p>All containers attached to a user-defined network can communicate using their names (automatic DNS resolution)..so you can contact the container <code>nginx</code> directly (you don't need to know its IP).</p> <p>Run the command <code>curl http://nginx</code> inside the ubuntu container to verify that the automatic DNS resolution is working:</p> <pre><code>root@2f03f1f2cd10:/# curl http://nginx\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Tip</p> <p>In order for the automatic DNS resolution to work you must assign custom names to the containers. Using the randomly generated name will not work.</p>"},{"location":"container/volume_plugin/","title":"Docker volume plugins - an example","text":"<p>Docker Engine volume plugins enable Engine deployments to be integrated with external storage systems such as NFS, Ceph, Openstack Cinder, Amazon EBS, and enable data volumes to persist beyond the lifetime of a single Docker host.</p> <p>This section will show an example using the Netshare docker volume plugin to mount NFS shares inside our container.</p> <p>Note</p> <p>Netshare is a Docker volume plugin for NFS 3/4, EFS and CIFS/SMB. We will show its usage with NFS as an example. However consider that you can attach NFS volumes to docker containers using the <code>local</code> driver as well since docker provides natively the support for NFS. For example: <pre><code># docker volume create --driver local --opt type=nfs --opt o=addr=&lt;nfs server ip&gt;,rw --opt device=:&lt;export nfs path&gt; &lt;volume name&gt;\n</code></pre></p> <p>The plugin has been installed following the instructions provided in the docs.</p> <p>The NFS server has been installed on the machine with IP <code>192.168.28.53</code> and configured to export the path <code>/mnt/nfs_share/nginx</code>:</p> <pre><code>Export list for 192.168.28.53:\n/mnt/nfs_share/nginx   192.168.28.151\n</code></pre> <p>You can check that the docker plugin service is up and running on the docker host:</p> <pre><code>sudo systemctl status docker-volume-netshare\n</code></pre> <pre><code>\u25cf docker-volume-netshare.service - LSB: Init for docker-volume-netshare\n     Loaded: loaded (/etc/init.d/docker-volume-netshare; generated)\n     Active: active (running) since Sun 2021-06-13 13:23:58 UTC; 1h 6min ago\n       Docs: man:systemd-sysv-generator(8)\n    Process: 716471 ExecStart=/etc/init.d/docker-volume-netshare start (code=exited, status=0/SUCCESS)\n      Tasks: 5 (limit: 4683)\n     Memory: 6.3M\n     CGroup: /system.slice/docker-volume-netshare.service\n             \u2514\u2500716480 /usr/bin/docker-volume-netshare nfs\n\nJun 13 13:23:58 tutorvm-1 systemd[1]: Starting LSB: Init for docker-volume-netshare...\nJun 13 13:23:58 tutorvm-1 docker-volume-netshare[716471]:  * Starting Docker-Volume-Netshare: docker-volume-netshare\nJun 13 13:23:58 tutorvm-1 docker-volume-netshare[716471]:    ...done.\nJun 13 13:23:58 tutorvm-1 systemd[1]: Started LSB: Init for docker-volume-netshare.\n</code></pre> <p>Launch the <code>nginx</code> container with an NFS docker volume:</p> <pre><code>docker run -d -p 8081:80 --name nginx_nfs --volume-driver=nfs -v 192.168.28.53/mnt/nfs_share/nginx:/usr/share/nginx/html nginx\n</code></pre> <p>Check the volume list:</p> <pre><code>docker volume ls\nDRIVER    VOLUME NAME\nnfs       192.168.28.53/mnt/nfs_share/nginx\n</code></pre> <p>Inspect the volume:</p> <pre><code>docker inspect 192.168.28.53/mnt/nfs_share/nginx\n[\n    {\n        \"CreatedAt\": \"0001-01-01T00:00:00Z\",\n        \"Driver\": \"nfs\",\n        \"Labels\": null,\n        \"Mountpoint\": \"/var/lib/docker-volumes/netshare/nfs/192.168.28.53/mnt/nfs_share/nginx\",\n        \"Name\": \"192.168.28.53/mnt/nfs_share/nginx\",\n        \"Options\": null,\n        \"Scope\": \"local\"\n    }\n]\n</code></pre> <p>The plugin has automatically mounted the NFS volume on your docker host...look at the mounts:</p> <pre><code>sudo mount | grep nginx\n192.168.28.53:/mnt/nfs_share/nginx on /var/lib/docker-volumes/netshare/nfs/192.168.28.53/mnt/nfs_share/nginx type nfs4 (rw,relatime,vers=4.2,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.28.151,local_lock=none,addr=192.168.28.53)\n</code></pre> <p>Now connect to the deployed service (<code>nginx</code>) on port <code>8081</code>:</p> <p></p>"},{"location":"container/volume_summary/","title":"Summary","text":""},{"location":"container/volumes/","title":"Docker volumes and bind-mounts","text":"<p>Whenever a running container wants to persist data, it actually put that data into the writable layer through storage driver.</p> <p>Let's use our <code>nginx2</code> container created previously.</p> <p>Tip</p> <p>If you don't have this container running you can recreate it with the following command: <code>docker container run -d -p 80:80 --name nginx2 nginx</code></p> <p>Let\u2019s use the <code>docker exec</code> command to edit the welcome page and load it.</p> <p><pre><code>docker container exec -it nginx2 bash\n</code></pre> You should now be inside your container. Run the following command to change the welcome page:</p> <pre><code>echo \"I changed the content of this file inside the running container...\" &gt; /usr/share/nginx/html/index.html\n</code></pre> <p>You will be able to see these changes connecting to the port 80 of your host:</p> <p></p> <p>Let\u2019s restart the container. What happens? We can still see the changes that we made. </p> <p>Now..what if we stop this container and start another one and load the page?</p> <pre><code>docker container run -d -p 8080:80 --name nginx3 nginx\n</code></pre> <p>Warning</p> <p>For this second container you need to specify a different host port, otherwise there will be a conflict and your container will not be started:</p> <p><code>driver failed programming external connectivity on endpoint nginx3 (96fad8e096e1a124147049765f0d734e2a034712fb253711450c62a7158b1f21): Bind for 0.0.0.0:80 failed: port is already allocated.</code></p> <p>Connect to port 8080 of your host, you will see the default welcome page: there is no way that we could access the file that we have changed in another container.</p> <p></p>"},{"location":"container/volumes/#using-docker-volumes","title":"Using docker volumes","text":"<p>Let's create our first docker volume:</p> <pre><code>docker volume create myvol\n</code></pre> <p>We can list the volumes with:</p> <pre><code>docker volume ls\n</code></pre> <pre><code>DRIVER    VOLUME NAME\nlocal     myvol\n</code></pre> <p>We can see the location of volumes in the docker area of the host file system with the inspect command:</p> <pre><code>docker volume inspect myvol\n</code></pre> <pre><code>[\n    {\n        \"CreatedAt\": \"2021-06-07T10:53:26Z\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/myvol/_data\",\n        \"Name\": \"myvol\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n</code></pre> <p>Let's re-create our <code>nginx</code> container with the following command that mounts the volume <code>myvol</code> in <code>/usr/share/nginx/html</code>:</p> <p>Remove the old container <pre><code>docker container rm -f nginx3\n</code></pre></p> <p>Recreate it with the volume mounted: <pre><code>docker container run -d -p 8080:80 --name nginx3 --mount type=volume,source=myvol,destination=/usr/share/nginx/html nginx\n</code></pre></p> <p>Note</p> <ul> <li>if we didn\u2019t create the volume earlier docker will create it for us with the name given in source field of <code>--mount</code> parameter</li> <li>volumes by default will not be deleted while we removing the container</li> <li>if the container has got in <code>target</code> directory any files, this files will be copied into the volume</li> </ul> <p>Enter the container and modify the welcome page:</p> <pre><code>docker exec -it nginx3 bash\n</code></pre> <p>Once inside the container, run the following command:</p> <pre><code>echo \"I've changed the content of this file in the docker volume\" &gt; /usr/share/nginx/html/index.html\n</code></pre> <p></p> <p>Let' stop and remove this container and create a new one with the same command:</p> <p><pre><code>docker rm -f nginx3\n</code></pre> then <pre><code>docker container run -d -p 8080:80 --name nginx3 --mount type=volume,source=myvol,destination=/usr/share/nginx/html nginx\n</code></pre></p> <p>If we load the page again we will still see the html file that we edited in the volume.</p>"},{"location":"container/volumes/#using-bind-mounts","title":"Using bind mounts","text":"<p>Note</p> <ul> <li>if we didn\u2019t create a directory on docker host earlier docker will not create it for us with <code>--mount</code> parameter, auto-creating is available only in older <code>--volume</code></li> <li>bind mounts by default will not be deleted while removing the container</li> <li>if the container has got in <code>target</code> directory any files, this files will NOT be copied into bind mount directory, bind directory will cover any files in a target container directory</li> </ul> <p>Try the following command:</p> <pre><code>docker container run -d -p 8088:80 --name nginx4 --mount type=bind,source=/tmp/nginx,destination=/usr/share/nginx/html nginx\n</code></pre> <p>You will get an error since the path <code>/tmp/nginx</code> does not exist: <pre><code>docker: Error response from daemon: invalid mount config for type \"bind\": bind source path does not exist: /tmp/nginx.\nSee 'docker run --help'.\n</code></pre></p> <p>Let's create the directory on the host:</p> <pre><code>mkdir /tmp/nginx\n</code></pre> <p>Now re-run the command for creating the container:</p> <pre><code>docker container run -d -p 8088:80 --name nginx4 --mount type=bind,source=/tmp/nginx,destination=/usr/share/nginx/html nginx\n</code></pre> <p>If you inspect the container you will see the bind-mount:</p> <pre><code>docker container inspect nginx4\n</code></pre> <pre><code>...\n            \"Mounts\": [\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/tmp/nginx\",\n                    \"Target\": \"/usr/share/nginx/html\"\n                }\n            ],\n...\n</code></pre> <p>Connect to port <code>8088</code> on the host IP to see the result:</p> <p></p> <p>As you can see we get an error message from nginx as the bind-mount has overwritten the content of <code>/usr/share/nginx/html</code> (Remember that the behaviour with docker volumes is different, any file inside the container is copied in the volume)</p> <p>Let's create the <code>index.html</code> file in the host path <code>/tmp/nginx</code>:</p> <pre><code>echo \"I've changed the content of this file on the host\" &gt; /tmp/nginx/index.html\n</code></pre> <p>Then reload the page in the browser:</p> <p> </p> <p>Question</p> <p>As done before, try to remove the container and recreate it with the same bind-mount...what happens?</p>"},{"location":"gui/portainer/","title":"Portainer","text":"<p>Portainer is a lightweight management UI which allows you to easily manage your different Docker environments (Docker hosts or Swarm clusters). Portainer is meant to be as simple to deploy as it is to use. It consists of a single container that can run on any Docker engine.</p>"},{"location":"gui/portainer/#installation","title":"Installation","text":"<pre><code>docker volume create portainer_data\n</code></pre> <pre><code>docker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce\n</code></pre>"},{"location":"gui/portainer/#usage","title":"Usage","text":"<p>The UI will be exposed on port <code>9000</code> and you will be asked to create the initial administrator setting a password:</p> <p></p> <p>Then choose to manage the local Docker environment and click on Connect:</p> <p></p> <p>If everything works as expected, You will then be shown the Portainer home page:</p> <p></p> <p>In the menu clicking on <code>Dashboard</code> will open a summary view of your docker engine:</p> <p></p> <p>Clicking on <code>Containers</code> will allow you to manage containers:</p> <p></p> <p>Then click on one running container to get the container status and menu from which you can see the log and statistics: </p> <p></p> <p></p> <p>Exercise</p> <p>Now go back to the <code>Containers</code> page and try to add a new container. </p>"},{"location":"intro/","title":"Docker info","text":"<p>You can get the basic information about your Docker configuration by executing:</p> Command <pre><code>docker info\n</code></pre> <p>You will get something like the following output:</p> <pre><code>Client:\n Context:    default\n Debug Mode: false\n Plugins:\n  app: Docker App (Docker Inc., v0.9.1-beta3)\n  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)\n  scan: Docker Scan (Docker Inc., v0.7.0)\n\nServer:\n Containers: 0\n  Running: 0\n  Paused: 0\n  Stopped: 0\n Images: 0\n Server Version: 20.10.6\n Storage Driver: overlay2\n  Backing Filesystem: extfs\n  Supports d_type: true\n  Native Overlay Diff: true\n  userxattr: false\n Logging Driver: json-file\n Cgroup Driver: cgroupfs\n Cgroup Version: 1\n Plugins:\n  Volume: local\n  Network: bridge host ipvlan macvlan null overlay\n  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog\n Swarm: inactive\n Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc\n Default Runtime: runc\n Init Binary: docker-init\n containerd version: 05f951a3781f4f2c1911b05e61c160e9c30eaa8e\n runc version: 12644e614e25b05da6fd08a38ffa0cfe1903fdec\n init version: de40ad0\n Security Options:\n  apparmor\n  seccomp\n   Profile: default\n Kernel Version: 5.4.0-60-generic\n Operating System: Ubuntu 20.04.1 LTS\n OSType: linux\n Architecture: x86_64\n CPUs: 2\n Total Memory: 3.844GiB\n Name: tutorvm-1\n ID: XQM7:BP2R:Y2C2:37N2:LFN6:HBUI:AFFK:U36L:HASH:HHNK:YUZV:EXKX\n Docker Root Dir: /var/lib/docker\n Debug Mode: false\n Registry: https://index.docker.io/v1/\n Labels:\n Experimental: false\n Insecure Registries:\n  127.0.0.0/8\n Live Restore Enabled: false\n\nWARNING: No swap limit support\n</code></pre> <p>The output contains information about your storage driver, your docker root directory, the supported plugins (volume, network, log), the default registry, etc.</p>"},{"location":"intro/container/","title":"Docker container lifecycle","text":"<p> Source: https://twitter.com/pierrecdn/status/620587662928424960</p> <ul> <li>docker create command will create a new Docker container with the specified docker image.   <pre><code>   docker create --name &lt;container name&gt; &lt;image name&gt;\n</code></pre></li> <li>docker start command can be used to start a stopped container.   <pre><code>docker start &lt;container name&gt;\n</code></pre></li> <li>docker run command does the work of both docker create and docker start command.   <pre><code>docker run -it --name &lt;container name&gt; &lt;image name&gt;\n</code></pre></li> <li>docker pause command can be used to pause the processes running inside the container (a SIGSTOP signal will be sent to the main process).   <pre><code>docker pause &lt;container name&gt;\n</code></pre></li> <li>docker unpause command allows to unpause the container.   <pre><code>   docker unpause &lt;container name&gt;\n</code></pre></li> <li>docker stop command can be used to stop all the processes running in the container: the main process inside the container receives a SIGTERM signal.   <pre><code>   docker stop &lt;container name&gt;\n</code></pre></li> <li>docker rm command is used to destroy a stopped container (with <code>--force</code> option you can destroy a running container, but it's better to stop it before)   <pre><code>docker rm &lt;container name&gt;\n</code></pre></li> <li>docker kill command will kill all the processes in the container: the main process will be sent a SIGKILL or any signal specified with option <code>\u2013signal</code>.   <pre><code>   docker kill &lt;container name&gt;  \n</code></pre></li> </ul>"},{"location":"intro/container/#docker-command-syntax","title":"Docker command syntax","text":"<p>Prior to version 1.13, Docker had only the previously mentioned command syntax. Later on, the command-line was restructured to have the following syntax:</p> <pre><code>docker &lt;object&gt; &lt;command&gt; &lt;options&gt;\n</code></pre> <p>In this syntax:</p> <ul> <li><code>object</code> indicates the type of Docker object you'll be manipulating. This can be a container, image, network or volume object.</li> <li><code>command</code> indicates the task to be carried out by the daemon, that is the run command.</li> <li><code>options</code> can be any valid parameter that can override the default behavior of the command, like the <code>--publish</code> option for port mapping.</li> </ul> <p>The commands in the previous sections can be re-written as <code>docker container &lt;command&gt;</code>, e.g. <code>docker container create</code> or <code>docker container run</code>.</p> <p>To learn more about the available commands, visit the official documentation.</p>"},{"location":"intro/hello-world/","title":"Run your first container","text":"<p>Let's create our first docker container:</p> Command <p><pre><code>docker container run hello-world\n</code></pre> Look at the output:</p> <pre><code>Unable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\nb8dfde127a29: Pull complete\nDigest: sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre> <p>Let's see what happened behind the scene...</p> <p></p> <p>You launched the command <code>docker run hello-world</code> where <code>hello-world</code> is the name of a docker image.</p> <p>The Docker client reached out to the daemon, telling it to get the hello-world image and run a container from that.</p> <p>The Docker daemon looked for the image within your local repository and realized that it's not there: <code>Unable to find image 'hello-world:latest' locally</code>.</p> <p>The daemon then contacted the default public registry which is Docker Hub and pulled in the latest copy of the <code>hello-world</code> image: <code>Pulling from library/hello-world</code>.</p> <p>The Docker daemon then created a new container from the freshly pulled image.</p> <p>Finally the Docker daemon ran the container created using the hello-world image.</p> <p>Hello World only function is to output the text you see in the terminal, after which the container exits.</p> <p>You can use the command <code>docker container ps</code> to list the running containers (use <code>-a</code> option to list all the stopped containers): <pre><code>docker container ps -a\n</code></pre></p> <p>You will find the container just started and run from the <code>hello-world</code> image: <pre><code>CONTAINER ID   IMAGE         COMMAND    CREATED              STATUS                          PORTS     NAMES\nc0ba7d45168a   hello-world   \"/hello\"   About a minute ago   Exited (0) About a minute ago             thirsty_poitras\n</code></pre></p> <p>Note</p> <p>When we create a container, if we don't give a specific name, Docker will pick one for us.</p> <p>It will be the concatenation of:</p> <ul> <li>A mood (furious, goofy, suspicious, boring...)</li> <li>The name of a famous inventor (tesla, darwin, wozniak...)</li> </ul> <p>Examples: <code>happy_curie</code>, <code>jovial_lovelace</code> ...</p>"},{"location":"intro/images/","title":"Where are Docker images stored?","text":"<p>The storage location of Docker images and containers depends on the operating system. The command <code>docker info</code> provides information about your Docker configuration, including the <code>Storage Driver</code> and the <code>Docker Root Dir</code>.</p> <p>On Ubuntu, Docker stores images and containers files under <code>/var/lib/docker</code>:</p> <pre><code>sudo ls /var/lib/docker/ -latr\ntotal 60\ndrwxr-xr-x 40 root root  4096 May 27 13:27 ..\ndrwx------  3 root root  4096 May 27 13:27 image\ndrwx------  2 root root  4096 May 27 13:27 trust\ndrwxr-x---  3 root root  4096 May 27 13:27 network\ndrwx------  2 root root  4096 May 27 13:27 swarm\ndrwx--x--x  4 root root  4096 May 27 13:27 buildkit\ndrwx------  2 root root  4096 May 27 13:27 runtimes\ndrwx--x--x 13 root root  4096 May 27 13:27 .\ndrwx-----x  3 root root  4096 May 27 18:23 volumes\ndrwx------  4 root root  4096 Jun  2 15:50 plugins\ndrwx------  2 root root  4096 Jun  3 10:58 tmp\ndrwx-----x  6 root root 12288 Jun  3 10:58 overlay2\ndrwx-----x  3 root root  4096 Jun  3 10:58 containers\n</code></pre> <p>Docker images are stored in <code>/var/lib/docker/overlay2</code>.</p> <p>Let's explore the content of our image <code>hello-world</code>:</p> Info <p>The command <code>docker inspect</code> returns low-level information on Docker objects (images, containers, networks, etc.).</p> <p>More info in the Docker official doc.</p> <pre><code>docker image inspect hello-world\n</code></pre> <pre><code>[\n    {\n        \"Id\": \"sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726\",\n        \"RepoTags\": [\n            \"hello-world:latest\"\n        ],\n....\n        \"GraphDriver\": {\n            \"Data\": {\n                \"MergedDir\": \"/var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/merged\",\n                \"UpperDir\": \"/var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/diff\",\n                \"WorkDir\": \"/var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/work\"\n            },\n            \"Name\": \"overlay2\"\n        },\n....\n</code></pre> <p>The <code>GraphDriver.Data</code> dictionary contains information about the layers of the image.</p> <p>In general, the LowerDir contains the read-only layers of an image. The read-write layer that represents changes are part of the UpperDir.</p> <p>The <code>hello-world</code> image is built starting from the base image <code>scratch</code> that is an explicitly empty image. </p> <p>The <code>hello-world</code> image therefore contains just one layer that adds the <code>hello</code> executable (statically linked) to the base empty image. </p> <p>Look at the content of the UpperDir:</p> <pre><code>sudo ls -latr /var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/diff\ntotal 24\n-rwxrwxr-x 1 root root 13336 Mar  5 23:25 hello\ndrwxr-xr-x 2 root root  4096 Jun  3 14:39 .\ndrwx-----x 3 root root  4096 Jun  3 14:39 ..\n</code></pre> <p>Another interesting command is <code>docker history</code> that shows the hystory of an image. Try it!</p> <pre><code>docker history hello-world\n</code></pre> <p>Output: <pre><code>IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT\nd1165f221234   2 months ago   /bin/sh -c #(nop)  CMD [\"/hello\"]               0B\n&lt;missing&gt;      2 months ago   /bin/sh -c #(nop) COPY file:7bf12aab75c3867a\u2026   13.3kB\n</code></pre></p> <p>Again, you can see here that the image has only one layer (0B lines are neglected).</p>"}]}